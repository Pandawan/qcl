"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = install;

var _moment = _interopRequireDefault(require("moment"));

var _data = require("../universal/data");

var _utils = require("../universal/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Installs the given package
 * @param pkgName The package to install
 */
async function install(pkgName, expiry) {
  if (!pkgName) {
    throw new Error('No package was given.');
  }

  if (expiry && (expiry.length !== 2 || !(0, _utils.isValidDuration)(expiry[0], expiry[1]))) {
    throw new Error('Incorrect value for expiry, must be in format "<amount><units>"');
  }

  const {
    packages
  } = (0, _data.getData)(); // If already installed, remove it so that it can be updated

  const pAlready = packages.findIndex(p => p.name === pkgName);

  if (pAlready >= 0) {
    packages.splice(pAlready, 1);
  }

  console.log(`Installing "${pkgName}"`); // Install the package

  const pkg = await installPackage(pkgName, expiry); // Add the package to the packages list and save it

  packages.push(pkg);
  (0, _data.setSingleData)('packages', packages);
  console.log(`Package "${pkgName}" was successfully installed.`);
}

async function installPackage(pkgName, expiry) {
  const pkg = {
    expiry: expiry || undefined,
    installed: (0, _moment.default)().toISOString(),
    name: pkgName
  };
  const {
    package_manager
  } = (0, _data.getData)();

  if (package_manager === 'npm') {
    // TODO: Allow for extra parameters such as --global and --saveDev
    console.log((await (0, _utils.getAsync)(`sudo npm install ${pkgName} -g`)));
  } else if (package_manager === 'yarn') {
    console.log((await (0, _utils.getAsync)(`sudo yarn global add ${pkgName}`)));
  }

  return pkg;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tYW5kcy9pbnN0YWxsLnRzIl0sIm5hbWVzIjpbImluc3RhbGwiLCJwa2dOYW1lIiwiZXhwaXJ5IiwiRXJyb3IiLCJsZW5ndGgiLCJwYWNrYWdlcyIsInBBbHJlYWR5IiwiZmluZEluZGV4IiwicCIsIm5hbWUiLCJzcGxpY2UiLCJjb25zb2xlIiwibG9nIiwicGtnIiwiaW5zdGFsbFBhY2thZ2UiLCJwdXNoIiwidW5kZWZpbmVkIiwiaW5zdGFsbGVkIiwidG9JU09TdHJpbmciLCJwYWNrYWdlX21hbmFnZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFFQTs7OztBQUVBOzs7O0FBSWUsZUFBZUEsT0FBZixDQUNiQyxPQURhLEVBRWJDLE1BRmEsRUFHYjtBQUNBLE1BQUksQ0FBQ0QsT0FBTCxFQUFjO0FBQ1osVUFBTSxJQUFJRSxLQUFKLENBQVUsdUJBQVYsQ0FBTjtBQUNEOztBQUVELE1BQ0VELE1BQU0sS0FDTEEsTUFBTSxDQUFDRSxNQUFQLEtBQWtCLENBQWxCLElBQXVCLENBQUMsNEJBQWdCRixNQUFNLENBQUMsQ0FBRCxDQUF0QixFQUEyQkEsTUFBTSxDQUFDLENBQUQsQ0FBakMsQ0FEbkIsQ0FEUixFQUdFO0FBQ0EsVUFBTSxJQUFJQyxLQUFKLENBQ0osaUVBREksQ0FBTjtBQUdEOztBQUVELFFBQU07QUFBRUUsSUFBQUE7QUFBRixNQUFlLG9CQUFyQixDQWRBLENBZ0JBOztBQUNBLFFBQU1DLFFBQVEsR0FBR0QsUUFBUSxDQUFDRSxTQUFULENBQW1CQyxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsSUFBRixLQUFXUixPQUFuQyxDQUFqQjs7QUFDQSxNQUFJSyxRQUFRLElBQUksQ0FBaEIsRUFBbUI7QUFDakJELElBQUFBLFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkosUUFBaEIsRUFBMEIsQ0FBMUI7QUFDRDs7QUFFREssRUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQWEsZUFBY1gsT0FBUSxHQUFuQyxFQXRCQSxDQXdCQTs7QUFDQSxRQUFNWSxHQUFHLEdBQUcsTUFBTUMsY0FBYyxDQUFDYixPQUFELEVBQVVDLE1BQVYsQ0FBaEMsQ0F6QkEsQ0EyQkE7O0FBQ0FHLEVBQUFBLFFBQVEsQ0FBQ1UsSUFBVCxDQUFjRixHQUFkO0FBQ0EsMkJBQWMsVUFBZCxFQUEwQlIsUUFBMUI7QUFFQU0sRUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQWEsWUFBV1gsT0FBUSwrQkFBaEM7QUFDRDs7QUFFRCxlQUFlYSxjQUFmLENBQ0ViLE9BREYsRUFFRUMsTUFGRixFQUdxQjtBQUNuQixRQUFNVyxHQUFhLEdBQUc7QUFDcEJYLElBQUFBLE1BQU0sRUFBRUEsTUFBTSxJQUFJYyxTQURFO0FBRXBCQyxJQUFBQSxTQUFTLEVBQUUsdUJBQVNDLFdBQVQsRUFGUztBQUdwQlQsSUFBQUEsSUFBSSxFQUFFUjtBQUhjLEdBQXRCO0FBTUEsUUFBTTtBQUFFa0IsSUFBQUE7QUFBRixNQUFzQixvQkFBNUI7O0FBRUEsTUFBSUEsZUFBZSxLQUFLLEtBQXhCLEVBQStCO0FBQzdCO0FBQ0FSLElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixFQUFZLE1BQU0scUJBQVUsb0JBQW1CWCxPQUFRLEtBQXJDLENBQWxCO0FBQ0QsR0FIRCxNQUdPLElBQUlrQixlQUFlLEtBQUssTUFBeEIsRUFBZ0M7QUFDckNSLElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixFQUFZLE1BQU0scUJBQVUsd0JBQXVCWCxPQUFRLEVBQXpDLENBQWxCO0FBQ0Q7O0FBQ0QsU0FBT1ksR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5cclxuaW1wb3J0IHsgZ2V0RGF0YSwgc2V0U2luZ2xlRGF0YSB9IGZyb20gJy4uL3VuaXZlcnNhbC9kYXRhJztcclxuaW1wb3J0IHsgRXhwaXJ5LCBJUGFja2FnZSB9IGZyb20gJy4uL3VuaXZlcnNhbC9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgZ2V0QXN5bmMsIGlzVmFsaWREdXJhdGlvbiB9IGZyb20gJy4uL3VuaXZlcnNhbC91dGlscyc7XHJcblxyXG4vKipcclxuICogSW5zdGFsbHMgdGhlIGdpdmVuIHBhY2thZ2VcclxuICogQHBhcmFtIHBrZ05hbWUgVGhlIHBhY2thZ2UgdG8gaW5zdGFsbFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaW5zdGFsbChcclxuICBwa2dOYW1lOiBzdHJpbmcsXHJcbiAgZXhwaXJ5OiBFeHBpcnkgfCB1bmRlZmluZWRcclxuKSB7XHJcbiAgaWYgKCFwa2dOYW1lKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhY2thZ2Ugd2FzIGdpdmVuLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKFxyXG4gICAgZXhwaXJ5ICYmXHJcbiAgICAoZXhwaXJ5Lmxlbmd0aCAhPT0gMiB8fCAhaXNWYWxpZER1cmF0aW9uKGV4cGlyeVswXSwgZXhwaXJ5WzFdKSlcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgJ0luY29ycmVjdCB2YWx1ZSBmb3IgZXhwaXJ5LCBtdXN0IGJlIGluIGZvcm1hdCBcIjxhbW91bnQ+PHVuaXRzPlwiJ1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgcGFja2FnZXMgfSA9IGdldERhdGEoKTtcclxuXHJcbiAgLy8gSWYgYWxyZWFkeSBpbnN0YWxsZWQsIHJlbW92ZSBpdCBzbyB0aGF0IGl0IGNhbiBiZSB1cGRhdGVkXHJcbiAgY29uc3QgcEFscmVhZHkgPSBwYWNrYWdlcy5maW5kSW5kZXgocCA9PiBwLm5hbWUgPT09IHBrZ05hbWUpO1xyXG4gIGlmIChwQWxyZWFkeSA+PSAwKSB7XHJcbiAgICBwYWNrYWdlcy5zcGxpY2UocEFscmVhZHksIDEpO1xyXG4gIH1cclxuXHJcbiAgY29uc29sZS5sb2coYEluc3RhbGxpbmcgXCIke3BrZ05hbWV9XCJgKTtcclxuXHJcbiAgLy8gSW5zdGFsbCB0aGUgcGFja2FnZVxyXG4gIGNvbnN0IHBrZyA9IGF3YWl0IGluc3RhbGxQYWNrYWdlKHBrZ05hbWUsIGV4cGlyeSk7XHJcblxyXG4gIC8vIEFkZCB0aGUgcGFja2FnZSB0byB0aGUgcGFja2FnZXMgbGlzdCBhbmQgc2F2ZSBpdFxyXG4gIHBhY2thZ2VzLnB1c2gocGtnKTtcclxuICBzZXRTaW5nbGVEYXRhKCdwYWNrYWdlcycsIHBhY2thZ2VzKTtcclxuXHJcbiAgY29uc29sZS5sb2coYFBhY2thZ2UgXCIke3BrZ05hbWV9XCIgd2FzIHN1Y2Nlc3NmdWxseSBpbnN0YWxsZWQuYCk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGluc3RhbGxQYWNrYWdlKFxyXG4gIHBrZ05hbWU6IHN0cmluZyxcclxuICBleHBpcnk6IEV4cGlyeSB8IHVuZGVmaW5lZFxyXG4pOiBQcm9taXNlPElQYWNrYWdlPiB7XHJcbiAgY29uc3QgcGtnOiBJUGFja2FnZSA9IHtcclxuICAgIGV4cGlyeTogZXhwaXJ5IHx8IHVuZGVmaW5lZCxcclxuICAgIGluc3RhbGxlZDogbW9tZW50KCkudG9JU09TdHJpbmcoKSxcclxuICAgIG5hbWU6IHBrZ05hbWUsXHJcbiAgfTtcclxuXHJcbiAgY29uc3QgeyBwYWNrYWdlX21hbmFnZXIgfSA9IGdldERhdGEoKTtcclxuXHJcbiAgaWYgKHBhY2thZ2VfbWFuYWdlciA9PT0gJ25wbScpIHtcclxuICAgIC8vIFRPRE86IEFsbG93IGZvciBleHRyYSBwYXJhbWV0ZXJzIHN1Y2ggYXMgLS1nbG9iYWwgYW5kIC0tc2F2ZURldlxyXG4gICAgY29uc29sZS5sb2coYXdhaXQgZ2V0QXN5bmMoYHN1ZG8gbnBtIGluc3RhbGwgJHtwa2dOYW1lfSAtZ2ApKTtcclxuICB9IGVsc2UgaWYgKHBhY2thZ2VfbWFuYWdlciA9PT0gJ3lhcm4nKSB7XHJcbiAgICBjb25zb2xlLmxvZyhhd2FpdCBnZXRBc3luYyhgc3VkbyB5YXJuIGdsb2JhbCBhZGQgJHtwa2dOYW1lfWApKTtcclxuICB9XHJcbiAgcmV0dXJuIHBrZztcclxufVxyXG4iXX0=