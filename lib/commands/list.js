"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = list;
exports.expireTime = expireTime;

var _moment = _interopRequireDefault(require("moment"));

var _table = require("table");

var _data = require("../universal/data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * List all packages installed
 */
async function list() {
  try {
    const data = (0, _data.getData)(); // If there are packages installed

    if (data.packages && data.packages.length !== 0) {
      console.log((await tableOutput(data)));
    } else {
      console.log('No packages installed.');
    }

    return data.packages;
  } catch (error) {
    throw error;
  }
}
/**
 * Create a formatted CLI table of all packages
 */


async function tableOutput(data) {
  // Prepare table columns using command options
  const tableData = [['Name', 'Installed', 'Expires']]; // Add table data

  for (const pkg of data.packages) {
    const values = [pkg.name, (0, _moment.default)(pkg.installed).format('YYYY-MM-DD hh:mmA'), expireTime(pkg.installed, pkg.expiry || data.expiry)];
    tableData.push(values);
  }

  return (0, _table.table)(tableData, {
    border: (0, _table.getBorderCharacters)('void'),
    columnDefault: {
      paddingLeft: 1,
      paddingRight: 1
    },
    drawHorizontalLine: () => false
  });
}
/**
 * Get when the package with the given install date will expire (in units)
 * @param installedDate The time at which the package was installed
 * @param preservationTime How long the package is supposed to be preserved
 */


function expireTime(installedDate, preservationTime) {
  // Calculate difference between expiry date & current date
  const timeDifference = (0, _moment.default)(installedDate).add(preservationTime[0], preservationTime[1]) // Use same units as preservationTime
  .diff((0, _moment.default)());
  return _moment.default.duration(timeDifference).humanize(true);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tYW5kcy9saXN0LnRzIl0sIm5hbWVzIjpbImxpc3QiLCJkYXRhIiwicGFja2FnZXMiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwidGFibGVPdXRwdXQiLCJlcnJvciIsInRhYmxlRGF0YSIsInBrZyIsInZhbHVlcyIsIm5hbWUiLCJpbnN0YWxsZWQiLCJmb3JtYXQiLCJleHBpcmVUaW1lIiwiZXhwaXJ5IiwicHVzaCIsImJvcmRlciIsImNvbHVtbkRlZmF1bHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImRyYXdIb3Jpem9udGFsTGluZSIsImluc3RhbGxlZERhdGUiLCJwcmVzZXJ2YXRpb25UaW1lIiwidGltZURpZmZlcmVuY2UiLCJhZGQiLCJkaWZmIiwibW9tZW50IiwiZHVyYXRpb24iLCJodW1hbml6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7OztBQUdBOzs7QUFHZSxlQUFlQSxJQUFmLEdBQTJDO0FBQ3hELE1BQUk7QUFDRixVQUFNQyxJQUFJLEdBQUcsb0JBQWIsQ0FERSxDQUdGOztBQUNBLFFBQUlBLElBQUksQ0FBQ0MsUUFBTCxJQUFpQkQsSUFBSSxDQUFDQyxRQUFMLENBQWNDLE1BQWQsS0FBeUIsQ0FBOUMsRUFBaUQ7QUFDL0NDLE1BQUFBLE9BQU8sQ0FBQ0MsR0FBUixFQUFZLE1BQU1DLFdBQVcsQ0FBQ0wsSUFBRCxDQUE3QjtBQUNELEtBRkQsTUFFTztBQUNMRyxNQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSx3QkFBWjtBQUNEOztBQUVELFdBQU9KLElBQUksQ0FBQ0MsUUFBWjtBQUNELEdBWEQsQ0FXRSxPQUFPSyxLQUFQLEVBQWM7QUFDZCxVQUFNQSxLQUFOO0FBQ0Q7QUFDRjtBQUVEOzs7OztBQUdBLGVBQWVELFdBQWYsQ0FBMkJMLElBQTNCLEVBQXlEO0FBQ3ZEO0FBQ0EsUUFBTU8sU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFELEVBQVMsV0FBVCxFQUFzQixTQUF0QixDQUFELENBQWxCLENBRnVELENBSXZEOztBQUNBLE9BQUssTUFBTUMsR0FBWCxJQUFrQlIsSUFBSSxDQUFDQyxRQUF2QixFQUFpQztBQUMvQixVQUFNUSxNQUFNLEdBQUcsQ0FDYkQsR0FBRyxDQUFDRSxJQURTLEVBRWIscUJBQU9GLEdBQUcsQ0FBQ0csU0FBWCxFQUFzQkMsTUFBdEIsQ0FBNkIsbUJBQTdCLENBRmEsRUFHYkMsVUFBVSxDQUFDTCxHQUFHLENBQUNHLFNBQUwsRUFBZ0JILEdBQUcsQ0FBQ00sTUFBSixJQUFjZCxJQUFJLENBQUNjLE1BQW5DLENBSEcsQ0FBZjtBQUtBUCxJQUFBQSxTQUFTLENBQUNRLElBQVYsQ0FBZU4sTUFBZjtBQUNEOztBQUVELFNBQU8sa0JBQU1GLFNBQU4sRUFBaUI7QUFDdEJTLElBQUFBLE1BQU0sRUFBRSxnQ0FBb0IsTUFBcEIsQ0FEYztBQUV0QkMsSUFBQUEsYUFBYSxFQUFFO0FBQ2JDLE1BQUFBLFdBQVcsRUFBRSxDQURBO0FBRWJDLE1BQUFBLFlBQVksRUFBRTtBQUZELEtBRk87QUFNdEJDLElBQUFBLGtCQUFrQixFQUFFLE1BQU07QUFOSixHQUFqQixDQUFQO0FBUUQ7QUFFRDs7Ozs7OztBQUtPLFNBQVNQLFVBQVQsQ0FBb0JRLGFBQXBCLEVBQTJDQyxnQkFBM0MsRUFBcUU7QUFDMUU7QUFDQSxRQUFNQyxjQUFjLEdBQUcscUJBQU9GLGFBQVAsRUFDcEJHLEdBRG9CLENBQ2hCRixnQkFBZ0IsQ0FBQyxDQUFELENBREEsRUFDS0EsZ0JBQWdCLENBQUMsQ0FBRCxDQURyQixFQUVyQjtBQUZxQixHQUdwQkcsSUFIb0IsQ0FHZixzQkFIZSxDQUF2QjtBQUtBLFNBQU9DLGdCQUFPQyxRQUFQLENBQWdCSixjQUFoQixFQUFnQ0ssUUFBaEMsQ0FBeUMsSUFBekMsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xyXG5pbXBvcnQgeyBnZXRCb3JkZXJDaGFyYWN0ZXJzLCB0YWJsZSB9IGZyb20gJ3RhYmxlJztcclxuXHJcbmltcG9ydCB7IGdldERhdGEgfSBmcm9tICcuLi91bml2ZXJzYWwvZGF0YSc7XHJcbmltcG9ydCB7IEV4cGlyeSwgSURhdGEsIElQYWNrYWdlIH0gZnJvbSAnLi4vdW5pdmVyc2FsL2ludGVyZmFjZXMnO1xyXG5cclxuLyoqXHJcbiAqIExpc3QgYWxsIHBhY2thZ2VzIGluc3RhbGxlZFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gbGlzdCgpOiBQcm9taXNlPElQYWNrYWdlW10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZGF0YSA9IGdldERhdGEoKTtcclxuXHJcbiAgICAvLyBJZiB0aGVyZSBhcmUgcGFja2FnZXMgaW5zdGFsbGVkXHJcbiAgICBpZiAoZGF0YS5wYWNrYWdlcyAmJiBkYXRhLnBhY2thZ2VzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhhd2FpdCB0YWJsZU91dHB1dChkYXRhKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gcGFja2FnZXMgaW5zdGFsbGVkLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXRhLnBhY2thZ2VzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBmb3JtYXR0ZWQgQ0xJIHRhYmxlIG9mIGFsbCBwYWNrYWdlc1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdGFibGVPdXRwdXQoZGF0YTogSURhdGEpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIC8vIFByZXBhcmUgdGFibGUgY29sdW1ucyB1c2luZyBjb21tYW5kIG9wdGlvbnNcclxuICBjb25zdCB0YWJsZURhdGEgPSBbWydOYW1lJywgJ0luc3RhbGxlZCcsICdFeHBpcmVzJ11dO1xyXG5cclxuICAvLyBBZGQgdGFibGUgZGF0YVxyXG4gIGZvciAoY29uc3QgcGtnIG9mIGRhdGEucGFja2FnZXMpIHtcclxuICAgIGNvbnN0IHZhbHVlcyA9IFtcclxuICAgICAgcGtnLm5hbWUsXHJcbiAgICAgIG1vbWVudChwa2cuaW5zdGFsbGVkKS5mb3JtYXQoJ1lZWVktTU0tREQgaGg6bW1BJyksXHJcbiAgICAgIGV4cGlyZVRpbWUocGtnLmluc3RhbGxlZCwgcGtnLmV4cGlyeSB8fCBkYXRhLmV4cGlyeSksXHJcbiAgICBdO1xyXG4gICAgdGFibGVEYXRhLnB1c2godmFsdWVzKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0YWJsZSh0YWJsZURhdGEsIHtcclxuICAgIGJvcmRlcjogZ2V0Qm9yZGVyQ2hhcmFjdGVycygndm9pZCcpLFxyXG4gICAgY29sdW1uRGVmYXVsdDoge1xyXG4gICAgICBwYWRkaW5nTGVmdDogMSxcclxuICAgICAgcGFkZGluZ1JpZ2h0OiAxLFxyXG4gICAgfSxcclxuICAgIGRyYXdIb3Jpem9udGFsTGluZTogKCkgPT4gZmFsc2UsXHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgd2hlbiB0aGUgcGFja2FnZSB3aXRoIHRoZSBnaXZlbiBpbnN0YWxsIGRhdGUgd2lsbCBleHBpcmUgKGluIHVuaXRzKVxyXG4gKiBAcGFyYW0gaW5zdGFsbGVkRGF0ZSBUaGUgdGltZSBhdCB3aGljaCB0aGUgcGFja2FnZSB3YXMgaW5zdGFsbGVkXHJcbiAqIEBwYXJhbSBwcmVzZXJ2YXRpb25UaW1lIEhvdyBsb25nIHRoZSBwYWNrYWdlIGlzIHN1cHBvc2VkIHRvIGJlIHByZXNlcnZlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZVRpbWUoaW5zdGFsbGVkRGF0ZTogc3RyaW5nLCBwcmVzZXJ2YXRpb25UaW1lOiBFeHBpcnkpIHtcclxuICAvLyBDYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGV4cGlyeSBkYXRlICYgY3VycmVudCBkYXRlXHJcbiAgY29uc3QgdGltZURpZmZlcmVuY2UgPSBtb21lbnQoaW5zdGFsbGVkRGF0ZSlcclxuICAgIC5hZGQocHJlc2VydmF0aW9uVGltZVswXSwgcHJlc2VydmF0aW9uVGltZVsxXSlcclxuICAgIC8vIFVzZSBzYW1lIHVuaXRzIGFzIHByZXNlcnZhdGlvblRpbWVcclxuICAgIC5kaWZmKG1vbWVudCgpKTtcclxuXHJcbiAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aW1lRGlmZmVyZW5jZSkuaHVtYW5pemUodHJ1ZSk7XHJcbn1cclxuIl19